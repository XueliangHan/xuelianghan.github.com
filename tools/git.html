<h3>Version Control System - Git</h3>

<hr>

<h4>Some words about VCS (Version Control System)</h4>

<ul>
<li>If you are the new generation (born after 1990), I think you should use Git instead of SVN or even Mercurial, bucause it's better. and if the new generation grow up with better tools, they will make better tools, so, after generation and generation, our world become much better.</li>
<li>The whole idea behind any version control system is to store "safe" copies of a project so that you never have to worry about irreparably breaking your code base.</li>
</ul>

<h4>Get the Git Program DONE</h4>

<ul>
<li>Install git
<ul>
<li>In Linux (Ubuntu): <code>sudo apt-get install git</code>  </li>
<li>In Mac OS X: Manually download git from website and install it.  </li>
</ul></li>
<li>Install a graphic history view program <br />
<ul>
<li>In Linux (Ubuntu): <code>sudo apt-get insatll tig</code>  </li>
<li>In Mac OS X: (tig, gitk) - tig (<code>brew install tig</code>), gitk (If you install git by using .dmg file, if will be automatically installed)  </li>
</ul></li>
<li>Configuration of Local Git and Remote Github Account
<ul>
<li><a href="https://help.github.com/articles/generating-ssh-keys">Generating SSH Keys</a></li>
</ul></li>
</ul>

<h4>Organizations at Github</h4>

<ul>
<li><a href="https://github.com/HackBerkeley">Hackers @ Berkeley</a> discoverd via <a href="https://github.com/pcottle">Peter Cottle</a></li>
<li><a href="https://github.com/apache">Apache</a></li>
<li><a href="https://github.com/alibaba">Alibaba Group</a></li>
<li><a href="https:/github.com/taobao">Taobao, Inc.</a></li>
</ul>

<h4>Learn - How to use Git</h4>

<ul>
<li>Git Recommended Tutorials
<ul>
<li><a href="http://www.atlassian.com/git/tutorial/git-basics">Git Tutorials &amp; Training</a> - Good tutorials</li>
<li><a href="http://happycasts.net/search?q=git">Git Video Tutorials</a> - Chinese video tutoirals</li>
<li><a href="https://pcottle.github.io/learnGitBranching/?demo">Learning Git Branching - Github</a></li>
</ul></li>
<li><a href="http://git-scm.com">Git-SCM Official Website</a>: Download it from website.</li>
<li><a href="https://git-scm.com/doc">Git-SCM Official Documents</a>: It's all here, Reference, Book, Videos, External Links, Linus Trovalds on Git.
<ul>
<li><a href="https://git-scm.com/docs/">Reference</a></li>
<li>(Book)<a href="https://git-scm.com/book">Pro Git</a></li>
<li><a href="https://git-scm.com/videos">Videos</a></li>
<li><a href="https://git-scm/doc/ext">External Links</a></li>
</ul></li>
</ul>

<h5>Git keywords and command</h5>

<ul>
<li>Stage, Tracked</li>
<li><a href="https://www.kernel.org/pub/software/scm/git/docs/everyday.html">Everyday GIT with 20 Command or So</a></li>
<li>(Chinese)<a href="http://robbinfan.com/blog/34/git-common-command">Git常用命令备忘</a>: Good summary.</li>
</ul>

<h5>1.Git Basic</h5>

<ul>
<li><strong><code>git init</code></strong>
<ul>
<li>First command you'll run in a new project.</li>
<li><code>git init</code>: Transform the current directory into a Git repository, this operation will add a <code>.git</code> folder to the current directory. </li>
<li><code>git init 'directory'</code>: Specify a directory you want to initialize into a repository, if the directory is not existed, Git will create it for you.</li>
<li><code>git init --bare 'directory'</code>: This the <code>--bare</code> flas is a way to make a repository as a storage facility, opposed to a development environment which will omit the working directory. Shared repositories should always be created with the <code>--bare</code> flas (ex. central repositories should always be created as bare repositories because pushing branches to a non-bare repository has the potential to overwrte changes), the central repository is bare, and developers local repositories are non-bare.</li>
<li>Example to create a central repository: 1.<code>ssh @ xxx</code>. 2.<code>cd path/repo</code>, 3.<code>git init --bare my-project.git</code>. First, SSH to your server. Then, navigate to wherever you's like to store the project. Finally, you use the <code>--bare</code> flag to create a central storage repository. Developer would then <code>clone</code> my-project.git to create a local copy on their development machine.</li>
</ul></li>
<li><strong><code>git clone</code></strong>
<ul>
<li><code>What is git clone?</code>: <code>git clone</code> is sort of like <code>svn checkout</code> which copies an existing Git repository but except the "working copy" is a full-fledged Git repository.</li>
<li><code>The different between SVN and Git</code>: SVN is <code>Central-Repo-to-Working-Copy Collaboration</code>, Git is Repo-to-Repo Collaboration`.</li>
<li><code>git clone 'repo'</code>: Clone the repository located at 'repo' onto the local machine, the original repo can be located on the local filesystem or on a remote machine accessible via HTTP or SSH.</li>
<li><code>git clone 'repo' 'directory'</code>: Clone the repository located at 'repo' into folder called 'directory' on the local machine.</li>
</ul></li>
<li><strong><code>git config</code></strong>
<ul>
<li><code>git config user.name 'name'</code>: Define the author name to be used in the current repository.</li>
<li><code>git config --global user.name 'name'</code>: Define the author name to be used for all commits by the current user.</li>
<li><code>git config --global user.email 'email'</code>: Define the author email to be used for all commit by the current user.</li>
<li><code>git config --global alias.'alias-name' 'git-command'</code>: Create a shortcut for a Git command.</li>
<li><code>git config --system core.editor 'editor'</code>: 'editor' argument should be the command that launches the desired editor (e.g, vi).</li>
<li><code>git config --global --edit</code>: Open the global configuration file in a text editor for manual editing.</li>
<li><code>git configuration files</code>: Git stores configuration options in three separate files, which lets you scope options to individual repositories, users, or the entire system, when options in these files conflict, local settings override user settings, user settings override system settings.
<blockquote>
  <p><code>'repo'/.git/config</code> - Repository-specific settings. <br />
  <code>~/.gitconfig</code> - User-specific settings. This is where options set with the --global flag are stored. <br />
  <code>$(prefix)/etc/gitconfig</code> - System-wide settings.  </li>
  <li><code>Recommendation</code>: I recommand you open configuration files and add below into it once and once for all.
  [user] <br />
  name = your-name <br />
  email = your-email <br />
  [alias] <br />
  st = status <br />
  co = checkout <br />
  br = branch <br />
  up = rebase <br />
  ci = commit <br />
  [core] <br />
  editor = vim  </li>
  </ul></li>
  <li><strong><code>git add</code></strong></p>
  
  <ul>
  <li><code>git add 'file'</code>: Stage all changes in 'file' for the next commit.</li>
  <li><code>git add 'directory'</code>: Stage all changes in 'directory' for the next commit.</li>
  <li><code>git add -p</code>: Begin an interactive staging session that lets you choose portions of a file to add to the next commit. This will present you with a hunk of changes and prompt you for a command. Use y to stage the hunk, n to ignore the hunk, s to split it into smaller hunks, e to manually edit the hunk, and q to exit.</li>
  <li><code>The Staging Area</code>: The staging area s one of Git's more unique features, and it can take some time to wrap your head around it if you's coming from an <code>SVN</code> (or even a <code>Mercurial</code>) background, it healps to think of it as a buffer between the working directory and the project history.</li>
  </ul></li>
  <li><strong><code>git commit</code></strong>
  <ul>
  <li><code>git commit</code> - Commit the staged snapshot. A text editor will be launched for you to write a commit message, entered a message -> save the file -> close the editor to create the actual commit.</li>
  <li><code>git commit -m "message"</code> - Commit the staged snapshot, use "Message" instead of launching a text editor.</li>
  <li><code>git commit -a</code> - Commit a snapshot of all changes in the working directory (Only includes modifications to tracked files which have been added with <code>git add</code> at some point in their history). </li>
  <li><code>Difference between Git and SVN</code> - Snapshots are always committed to the local repository, this is fundamentally different than SVN, wherein te working copy is committed to the central repository. In contrast, Git doesn't force you to interact with the central repository until you're ready. You can commit to local repository after a function or module is done, and push them to remote at once, this is a ballance of controling the repository size and the commit review. Just as the staging area is a buffer between the working directory and the project history, each developer's local repository is a buffer between their contributions and the central repository.</li>
  <li><code>Snapshots, Not Differences</code> - Git's snapshot model has a far-reaching impact on virtually every aspect of its version control model. SVN recodig file diffs and Git record snapshots which makes many Git operations much faster than SVN (A particular version of a file doesn't have to be "assembled" from its diffs - the complete version of each file is immediately available from Git's internal database.</li>
  <li>(Pay attention): the timestamp <code>git commit</code> command record is the time you commit, not the time you <code>git push</code>, I actually got confused, haha.</li>
  </ul></li>
  <li><strong><code>git status</code></strong>
  <ul>
  <li><code>git status</code> - The <code>git status</code> command displays the state of the working directory and the staging area. It lets you see which changes have been <code>staged</code>, which haven't, and which files aren't being <code>tracked</code> by Git, and it also include relevant instructions for staging /unstaging files.</li>
  <li>Status output does not show you any information regarding the committed project history. For this, you need to use <code>git log</code>.</li>
  <li><code>Ignoring Files</code> - Untracked files typically fall into two categories: 1.They are files that have just added to the project and haven't been committed yet. 2.They're compiled binaries like <code>.pyc</code>, <code>.obj</code>, <code>.exe</code>, <code>etc.</code>, the compiled binaries will make it hard to see what's actually going on in your repository, for this reason, a special file called <code>.gitignore</code> is for you to add the files you want to ignored, and these files will not appearing in <code>git status</code>. (An example of <code>.gitignore</code> file content: <em>.</em>.swp)</li>
  </ul></li>
  <li><strong><code>git log</code></strong>
  <ul>
  <li>The <code>git log</code> command displays committed snapshots. It lets you <code>list</code> the <em>project history</em>, <code>filter</code> it, and <code>search</code> for specific changes. While <code>git status</code> lets you inspect the <em>working directory</em> and the <em>staging</em> area, <code>git log</code> only operates on the committed history.</li>
  <li><code>Identification</code> - the 40 character string is an SHA-1 checksum of cmomits contents. This serves two purposes, First, it ensures the integrity of the commit - if it was ever corrupted, the commit world generate a different checksum. Second, it serves as a unique ID for the commit. <em>The idea behind all of these identification methods is to let you perform actions based on specific commits.</em></li>
  <li><strong><code>git log</code></strong> - Display the entire commit history using the default formatting. If the output takes up more than one screen, you can use Space to scroll and q to exit.</li>
  <li><strong><code>git log -n "limit"</code></strong>  - Limit the number of commits by "limit" . For example, git log -n 3 will display only 3 commits.</li>
  <li><strong><code>git log --oneline</code></strong>  - Condense each commit to a single line. This is useful for getting a high-level overview of the project history.</li>
  <li><strong><code>git log --stat</code></strong>  - Along with the ordinary git log information, include which files were altered and the relative number of lines that were added or deleted from each     of them.   </li>
  <li><strong><code>git log -p</code></strong>  - Display the patch representing each commit. This shows the full diff of each commit, which is the most detailed view you can have of your project histo    ry.</li>
  <li><strong><code>git log --author="pattern"</code></strong>  - Search for commits by a particular author. The  argument can be a plain string or a regular expression.</li>
  <li><strong><code>git log --grep="pattern"</code></strong>  - Search for commits with a commit message that matches "pattern" , which can be a plain string or a regular expression.</li>
  <li><strong><code>git log "since".."until"</code></strong>  - Show only commits that occur between "since" and "until". Both arguments can be either a commit ID, a branch name, HEAD, or any other kin    d of revision reference.</li>
  <li><strong><code>git log "file"</code></strong>  - Only display commits that include the specified file. This is an easy way to see the history of a particular file.</li>
  <li><strong><code>git log --graph --decorate --oneline</code></strong>  - A few useful options to consider. The --graph flag that will draw a text based graph of the commits on the left hand side of     the commit messages. --decorate adds the names of branches or tags of the commits that are shown. --oneline shows the commit information on a single line making it easier to b    rowse through commits at-a-glance.</li>
  </ul></li>
  </ul>
  
  <h5>2.Undoing Changes</h5>
</blockquote>

<ul>
<li><strong><code>git checkout</code></strong>
<ul>
<li><code>Used to do</code> -  1.checking out <em>files</em>, 2.checking out <em>commits</em>, 3.checking out <em>branches</em>.</li>
<li><code>checking out a file</code> - Checking out a file lets you see an old version of that particular file, leaving the rest of your working directory untouched.</li>
</ul></li>
<li><strong><code>git revert</code></strong>
<ul>
<li><code>git revert "commit"</code> - Generate a new commit that undoes all of the changes introduced in commit, then apply it to the current branch.</li>
</ul></li>
<li><strong><code>git reset</code></strong></li>
<li><strong><code>git clean</code></strong></li>
</ul>

<h5>3.Git Branches</h5>

<ul>
<li><strong><code>git branch</code></strong>
<ul>
<li><code>git branch</code> - </li>
<li><code>git branch "branch-name"</code> - </li>
<li>Marked</li>
</ul></li>
<li><strong><code>git checkout</code></strong>
<ul>
<li><code>what is git checkout command</code> - </li>
<li><code>git checkout "new-branch"</code> - </li>
<li><code>git checkout -b "new-branch"</code> - </li>
<li><code>git checkout -b "new-branch" "existing-branch"</code> - </li>
</ul></li>
<li><strong><code>git merge</code></strong>
<ul>
<li><code>what is git merge</code> - Merging is Git's way of putting a forked history back together again.</li>
<li><code>git merge "branch"</code> - Merge the specified branch into the current branch. Git will determine the merge algorithm automatically (discussed below).</li>
<li><code>git merge --no-ff "branch"</code> - </li>
</ul></li>
</ul>

<h5>4.Rewriting Git History</h5>

<ul>
<li><strong><code>git commit --amend</code></strong></li>
<li><strong><code>git rebase</code></strong></li>
<li><strong><code>git rebase -i</code></strong></li>
<li><strong><code>git reflog</code></strong></li>
</ul>

<h5>5.Remote Repositories</h5>

<ul>
<li><strong><code>git remote</code></strong>
<ul>
<li>SVN is type of central model, Git is collaboration model which give every developer their own copy of repository.</li>
<li><code>git remote</code>: List the remote connections you have to other repositories.</li>
<li><code>git remote -v</code>: Same as above command, but include the URL of each connection.</li>
<li><code>git remote add 'lname' 'url'</code>: Create a new connection to a remote repository. After adding a remote, you'll be able to use 'name' as a convenient shortcut for 'url' in other Git commands. Note: lname is short for link-name.</li>
<li><code>git remote rm 'name'</code>: Remove the connection to the remote repository called.</li>
<li><code>git remote rename 'old-name' 'new-name'</code>: Rename a remote connection from 'old-name' to 'new-name'.</li>
<li>Git is designed to give each developer an entirely isolated development environment, this means that information is not automatically passed back and forth between reositories, developers need to manually pull upstream commits into their local repository or manually push their local commits back up to the central repository. But this way also give a developer freedom to go anywhere without worry about the network connection, bacause all data is in local and you can finish all operation in local, after you get network access, you just <code>push</code> it.</li>
<li>The <code>origin</code> Remote: When you clone a repository with <code>git clone</code>, it automatically creates a remote connection called origin pointing back to the cloned repository, this behavior is also why most Git-based projects call their central repository origin. Note: I like <code>origin</code> this name, <code>origin</code> is also mean TRUTH.</li>
<li>Repository <code>URL's</code>: Git supports many ways to reference a remote repository. Access a remote repo via the HTTP and the SSH protocols is two easiest ways. HTTP allow anonymous, read-only access to a repository, but you can push commits to an HTTP address. If you want to push commits, you need a valid SSH account on the host machine, about SSH key, this will help: <a href="https://help.github.com/articles/generating-ssh-keys">Generating SSH Keys</a>.</li>
</ul></li>
<li><strong><code>git fetch</code></strong>
<ul>
<li>Purpose: Fetching is what you do when you want to see what everybody has been working on, it have no affect on your local development work, it's a safe way to review commits before integrating them with your local repository, it's different from SVN which force you to merge changes into your repository.</li>
<li><code>git fetch 'remote'</code>: Fetch all of the branch from the repository, and download all of required commits and files from the repository.</li>
<li><code>git fetch 'remote' 'branch'</code>: Only fetch specified branch.</li>
</ul></li>
<li><strong><code>git pull</code></strong>
<ul>
<li><code>git pull 'remote'</code>: <code>Fetch</code> the specified remote's copy of current branch and imediately <code>merge</code> it into the local copy. Same as the command : <code>git fecth 'remote'</code> + <code>git merge origin/'current-branch'</code>.</li>
<li><code>git pull --rebase 'remote'</code>: Same as the command: <code>git fetch 'remote'</code> + <code>git rebase 'remote'</code>, <code>--rebase</code> option can be used to ensure a linear history by preventing unnecessary merge commits, many developers prefer rebasing over merging, this put your changes on top of what everybody else has done, examples: <code>git checkout master</code> <code>git pull --rebase origin</code>.</li>
</ul></li>
<li><strong><code>git push</code></strong>
<ul>
<li><code>git push 'branch'</code>: Push the specified branch to 'remote', to prevent you from overwriting commits, Git won't let you push when it results in a non-fast-forward merge in the destination repository.</li>
<li><code>git push --force</code>: Same as above, but force the push even if it results in a non-fast-forward merge, do not use the <code>--force</code> flag unless you're absolutely sure you knon what you are doing.</li>
<li><code>git push --tags</code>: Sends all of your local tags to the remote repository which are not automatically pushed when you use <code>--all</code> option.</li>
</ul></li>
</ul>

<h4>My previous notes about Git Command</h4>

<ul>
<li>touch README.md: README.md, description about project.</li>
<li>git init: init a local git codebase, generate a hidden .git directory(use ls-aF command to view hidden .git diectory).</li>
<li>git add README.md: add README.md into codebase.</li>
<li>git commit -m "first commit": commit description, comment is necessary, it's a good design.</li>
<li>git remote add origin https://githhub.com/your-user-name/your-project-name.git, or git@github.com:your-user-name/your-project-name.git</li>
<li>git push origin master: push local codebase into remote branch of master.`</li>
</ul>

<h4>Troubleshooting</h4>

<ul>
<li>Git on Windows - Each time I want to push my file to github, it's always show me notification to enter my passphrase
<ul>
<li><a href="http://stackoverflow.com/questions/8518515/how-to-make-windows-remember-my-passphrase-key">How to make windows remember my passphrase key? - StackOverflow</a></li>
</ul></li>
</ul>
